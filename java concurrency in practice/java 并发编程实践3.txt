可见性问题：
编译器、处理器、runtime都有可能进行指令重排序，导致可见性问题。
对于long和double等64位的可变变量，没有经过同步的读写是不安全的。需要使用volatile或者锁保护起来。
volatile保证变量是从主存中读写，不会产生读写的缓存不同步问题。

volatile只保证可见性。加锁即保证了可见性，又保证了原子性。

线程封闭
线程封闭是指数据不被各个线程共享，只由单个线程拥有，从而保证数据安全：
ad-hoc封闭、栈封闭、ThreadLocal
当心对象的逸出(escape),比如private变量被public方法共享出去，比如对象构造时this指针被外部获取到
（在构造函数中开始一个线程，线程就拥有了对象的this指针，造成逸出）

不可变对象
不可变对象是指final型并且被正确构造(this指针没有逸出)的对象，不变对象也是线程安全的。

安全地发布一个对象的方式（就是创建一个对象给出去用，要防止因多线程问题乱new）
1.在静态函数中初始化一个对象引用。
2.将对象引用保存到一个正确构造对象的final域中。
3.将对象引用保存到volatile类型的域获atomicReference对象中
4.将对象引用保存到一个锁保护的域中
如果对象安全发布，并且之后不再改变，称为“事实不可变对象(effectively immutable object)”,无需额外同步即可安全访问，
在java中，将对象放到这些结构中发布可以实现这个情况。
Hashtable，synchronizedMap,ConcurrentMap
Vector,CopyOnWriteArrayList,CopyOnWriteArraySet,synchronizedList,synchronizedSet
BlockingQueue,ConcurrentLinkedQueue

也就是说，
不可变对象可以用任意方式发布。
事实不可变对象必须通过安全方式发布。
可变对象必须通过安全方式发布，并且需要线程安全地访问或者用锁保护起来。

总结:
在并发程序中，使用和共享对象时，可以使用的策略包括：
1.线程封闭。对象只能由一个线程拥有和修改。
2.只读共享。共享的只读对象可以不做同步，由多个线程并发访问。包括不可变对象和事实不可变对象。
3.线程安全共享。在对象内部实现同步，提供公有借口给多个线程访问。
4.保护对象。只能持有特定锁才能访问。包括封装在线程安全对象中的对象，和由特定锁保护的对象。

