线程安全性
无状态的对象一定是线程安全的。
*因为不存在共享的东西，只在调用方法的过程都是各自new。servlet大都是无状态的，保证了线程安全性。

**********
Condition Race和Data Race
解决方法：
原子变量(java.util.concurrent.atomic)，原子操作(CAS)
加锁，内部锁(synchronized),重入锁(reentrant lock）

**********
重入的概念
重入的锁粒度很细，是线程，不是调用。实现方式是Lock记录一个count和当前线程。线程不是当前线程就锁，count为0时可进入。
注意，内部锁和重入锁都是基于这个语义的。相比来说，重入锁增加了一些特性，而且在激烈争用的情况下性能更好(很少有这种状况)，
主要缺点是使用不够方便(千万不要为了性能牺牲简单性，会不利维护，出现各种问题)，一般尽量使用同步锁。

**********
锁的使用规范
每个共享的可变变量都应当只用一个锁来保护，便于维护。
具体来说，比如直接对变量加锁(使用同步结构);或者封装对变量的操作，控制变量可见性，只暴露一些同步的方法供调用。

*对io操作等时间较长或者可能完不成的操作，一定不要用锁。